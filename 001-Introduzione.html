<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Introduzione
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="author" content="nholz">
    <link rel="shortcut icon" type="image/x-icon" href="/nholz//img/favicon.ico">
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script> -->

    <link type="text/css" rel="stylesheet" href="/nholz/content/fsdocs-default.css" />
    <link type="text/css" rel="stylesheet" href="/nholz/content/fsdocs-custom.css" />
    <script type="text/javascript" src="/nholz/content/fsdocs-tips.js"></script>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!-- BEGIN SEARCH BOX: this adds support for the search box -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/JavaScript-autoComplete/1.0.4/auto-complete.css" />
    <!-- END SEARCH BOX: this adds support for the search box -->
    
</head> 

<body>
    <div class="columns is-fullheight m-0">
        <div id="fsdocs-menu" class="column is-2 is-paddingless">
            <aside class="menu">
                <div class="container is-paddingless is-marginless has-background-dark">
                    <a href="/nholz/">
                        <figure class="image is-128x128 container">
                            <img src="/nholz/img/logo.png">
                        </figure>
                    </a>
                    <h2 class="title has-text-centered has-text-white pb-4">nholz</h2>
                </div>
                <div class="content">
                    <!-- BEGIN SEARCH BOX: this adds support for the search box -->
                    <div id="header">
                        <div class="searchbox" id="fsdocs-searchbox">
                            <label for="search-by">
                                <i class="fas fa-search"></i>
                            </label>
                            <input data-search-input="" id="search-by" type="search" placeholder="Search..." class="input"/>
                            <span data-search-clear="">
                                <i class="fas fa-times"></i>
                            </span>
                        </div>
                    </div>
                    <!-- END SEARCH BOX: this adds support for the search box -->
                    <ul class="navbar-nav">
                        <li class="nav-header">Links</li>
                        <li class="nav-item" id="fsdocs-license-link"><a class="nav-link" href="{{fsdocs-license-link}}">License (MIT)</a></li>
                        <li class="nav-item" id="fsdocs-release-notes-link"><a class="nav-link" href="{{fsdocs-release-notes-link}}">Release Notes</a></li>
                        <li class="nav-item" id="fsdocs-repository-link"><a class="nav-link" href="{{fsdocs-repository-link}}">Source Repository</a></li>
                        <li class="nav-header">Il sistema HOL</li>
                        <li class="nav-item" id="index-link"><a class="nav-link" href="/index.html">Indice</a></li>
                        <li class="nav-header">
  API Reference
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/reference/index.html">
    All Namespaces
  </a>
</li>
                    </ul>
                </div>
            </aside>
        </div>
        <div class="column is-10 is-paddingless">
            <div class="section pt-4">
                <div class="container" id="fsdocs-content">
                    <h1><a name="Introduzione" class="anchor" href="#Introduzione">Introduzione</a></h1>
<p>HOL Zero è un dimostratore di teoremi minimale nella logica HOL. NHOLZ è un porting di HOL Zero in F# che ha lo scopo di avere un dimostratore di teoremi HOL, cioè un programma che supporta dimostrazioni formali e lo sviluppo di teorie nella logica HOL (si veda più avanti), a disposizione in F# per lo studio a livello personale di sistemi di questo tipo. Ho scelto HOL Zero come base perché è un dimostratore di teoremi relativamente semplice che si concentra su buone funzionalità di base, robustezza architetturale, lo sviluppo della sintassi concreta, un prettyprinting completo e non ambiguo, e la leggibilità del codice sorgente e perché per le sue caratteristiche è risultato piuttosto semplice effettuarne il porting.</p>
<p>Si tratta di un sistema non adatto allo sviluppo di dimostrazioni di grandi dimensioni. Esso, infatti, supporta soltanto uno stile di dimostrazione nella semplice deduzione naturale, e manca di funzionalità interattive ed automatiche  avanzate che altri sistemi HOL hanno.</p>
<h2><a name="1-1-Concetti-Base" class="anchor" href="#1-1-Concetti-Base">1.1 Concetti Base</a></h2>
<p>L'interazione utente con un sistema HOL avviene immettendo istruzioni a riga di comando in formato ASCII in una sessione interativa dell'interprete. Queste istruzioni sono di fatto espressioni nel linguaggio di programmazione che vengono valutate dall'interprete REPL una volta immesse.</p>
<p>Coloro che hanno una più profonda conoscenza del linguaggio possono estenderne le funzionalità. Una modalità di estensione consiste nell'immettere definizioni in una sessione. Qualsiasi di queste estensioni sono sicure nel senso che non possono introdurre incoerenze logiche nel sistema. Questa sicurezza è garantita dal fatto che il sistema è implementato secondo quella che viene chiamata un'architettura nello ''stile LCF'' (si veda la Sessione 4.1.3).</p>
<p><strong>1.1.2 La logica HOL</strong></p>
<p>La logica HOL qui utilizzata è una logica predicativa tipizzata, classica, di ordine superiore, cioè una logica predicativa con un sistema di tipi, con la legge del terzo escluso come teorema, e con la possibilità di quantificare su funzioni. E' basata sul lambda calcolo tipizzato di Alonzo Church. Ha un sistema polimorfico di tipi relativamente semplice che non è dipendentemente tipizzato e non supporta la quantificazione su variabili di tipo. Si faccia riferimento al glossario per una spiegazione estesa di questi concetti.</p>
<p>La logica HOL fu sviluppata per la prima volta negli anni 1980 per un sistema prototipo chiamato Cambridge HOL, ed è ora supportata dalla famiglia di dimostratori di teoremi HOL che include HOL4, ProofPower HOL, HOL Light e Isabelle/HOL. Questi sistemi sono stati utilizzati come strumenti affidabili essenziali in una varietà di progetti industriali, che includono la verifica dello sviluppo di microcircuiti integrati per computer e software safety-critical. Essi sono anche preminenti nella formalizzazione della matematica, in particolare nell'innovativo progetto Flyspeck di Tom Hales per formalizzare la sua dimostrazione della congettura di Keplero.</p>
<p><strong>1.1.3 Common HOL</strong></p>
<p>Common HOL è uno standard per le funzionalità di base di un sistema HOL, che ha lo scopo di facilitare la portabilità del codice sorgente e delle dimostrazioni formali tra i membri della famiglia HOL. Esso consiste nelle seguenti componenti:</p>
<ul>
<li>la specifica di una API di funzionalità HOL di base, per permettere il porting del codice sorgente tra sistemi HOL compatibili;</li>
<li>l'implementazione dell'API per vari sistemi HOL;</li>
<li>la specifica di un formato di file di dimostrazione, per permettere il porting delle dimostrazioni formali tra sistemi HOL compatibili;</li>
<li>l'implementazioni di oggetti per l'esportazione e l'importazione delle dimostrazioni tra vari sistemi HOL.</li>
</ul>
<p>NHOLZ, in generale, supporta lo standard Common HOL avendolo ereditato da HOL Zero. Va, tuttavia, notato che non supporta le term e le type quotation.</p>
<h2><a name="1-2-Avviare-una-sessione" class="anchor" href="#1-2-Avviare-una-sessione">1.2 Avviare una sessione</a></h2>
<p>Una sessione è avviata da uno script F#. Innanzitutto è necessario referenziare la dll e importare i relativi moduli:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="pp">#I</span> <span class="s">&quot;../src/bin/Debug/net7.0&quot;</span>
<span class="pp">#r</span> <span class="s">&quot;nholz.dll&quot;</span>
<span class="k">open</span> <span onmouseout="hideTip(event, 'fs1', 1)" onmouseover="showTip(event, 'fs1', 1)" class="id">HOL</span>
</code></pre>
<p>impostare il pretty printing delle espressioni:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="id">fsi</span><span class="pn">.</span><span class="id">AddPrinter</span> <span onmouseout="hideTip(event, 'fs2', 2)" onmouseover="showTip(event, 'fs2', 2)" class="id">print_type</span>
<span class="id">fsi</span><span class="pn">.</span><span class="id">AddPrinter</span> <span onmouseout="hideTip(event, 'fs3', 3)" onmouseover="showTip(event, 'fs3', 3)" class="id">print_qtype</span>
<span class="id">fsi</span><span class="pn">.</span><span class="id">AddPrinter</span> <span onmouseout="hideTip(event, 'fs4', 4)" onmouseover="showTip(event, 'fs4', 4)" class="id">print_term</span>
<span class="id">fsi</span><span class="pn">.</span><span class="id">AddPrinter</span> <span onmouseout="hideTip(event, 'fs5', 5)" onmouseover="showTip(event, 'fs5', 5)" class="id">print_qterm</span>
<span class="id">fsi</span><span class="pn">.</span><span class="id">AddPrinter</span> <span onmouseout="hideTip(event, 'fs6', 6)" onmouseover="showTip(event, 'fs6', 6)" class="id">print_thm</span>
</code></pre>
<p>e caricare quindi i moduli con i seguenti comandi:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs7', 7)" onmouseover="showTip(event, 'fs7', 7)" class="m">CoreThry</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs8', 8)" onmouseover="showTip(event, 'fs8', 8)" class="id">load</span>
<span onmouseout="hideTip(event, 'fs9', 9)" onmouseover="showTip(event, 'fs9', 9)" class="m">Equal</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs10', 10)" onmouseover="showTip(event, 'fs10', 10)" class="id">load</span>
<span onmouseout="hideTip(event, 'fs11', 11)" onmouseover="showTip(event, 'fs11', 11)" class="m">Bool</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs10', 12)" onmouseover="showTip(event, 'fs10', 12)" class="id">load</span>
<span onmouseout="hideTip(event, 'fs12', 13)" onmouseover="showTip(event, 'fs12', 13)" class="m">BoolAlg</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs10', 14)" onmouseover="showTip(event, 'fs10', 14)" class="id">load</span>
<span onmouseout="hideTip(event, 'fs13', 15)" onmouseover="showTip(event, 'fs13', 15)" class="m">BoolClass</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs10', 16)" onmouseover="showTip(event, 'fs10', 16)" class="id">load</span>
<span onmouseout="hideTip(event, 'fs14', 17)" onmouseover="showTip(event, 'fs14', 17)" class="m">Pair</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs10', 18)" onmouseover="showTip(event, 'fs10', 18)" class="id">load</span>
<span onmouseout="hideTip(event, 'fs15', 19)" onmouseover="showTip(event, 'fs15', 19)" class="m">Ind</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs10', 20)" onmouseover="showTip(event, 'fs10', 20)" class="id">load</span>
<span onmouseout="hideTip(event, 'fs16', 21)" onmouseover="showTip(event, 'fs16', 21)" class="m">Nat</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs10', 22)" onmouseover="showTip(event, 'fs10', 22)" class="id">load</span>
<span onmouseout="hideTip(event, 'fs17', 23)" onmouseover="showTip(event, 'fs17', 23)" class="m">NatNumrl</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs10', 24)" onmouseover="showTip(event, 'fs10', 24)" class="id">load</span>
<span onmouseout="hideTip(event, 'fs18', 25)" onmouseover="showTip(event, 'fs18', 25)" class="m">NatArith</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs10', 26)" onmouseover="showTip(event, 'fs10', 26)" class="id">load</span>
<span onmouseout="hideTip(event, 'fs19', 27)" onmouseover="showTip(event, 'fs19', 27)" class="m">NatRel</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs10', 28)" onmouseover="showTip(event, 'fs10', 28)" class="id">load</span>
<span onmouseout="hideTip(event, 'fs20', 29)" onmouseover="showTip(event, 'fs20', 29)" class="m">NatEval</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs10', 30)" onmouseover="showTip(event, 'fs10', 30)" class="id">load</span>
</code></pre>
<p>I primi pochi secondi di avvio richiedono il build del sistema da zero. Alcune centinaia di righe di output scorrono velocemente sullo schermo.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// ...</span>
<span class="c">// [HZ] Storing theorem &quot;sub_floor_thm&quot;.</span>
<span class="c">// [HZ] Setting term fixity for name &quot;&gt;&quot;.</span>
<span class="c">// [HZ] Declaring constant &quot;&gt;&quot;.</span>
<span class="c">// [HZ] Adding definition for constant &quot;&gt;&quot;.</span>
<span class="c">// [HZ] Setting term fixity for name &quot;&gt;=&quot;.</span>
<span class="c">// [HZ] Declaring constant &quot;&gt;=&quot;.</span>
<span class="c">// [HZ] Adding definition for constant &quot;&gt;=&quot;.</span>
<span class="c">// val it : (string * thm) list =</span>
<span class="c">//   [(&quot;eta_ax&quot;, |- !(f:&#39;a-&gt;&#39;b). (\x. f x) = f);</span>
<span class="c">//    (&quot;imp_antisym_ax&quot;, |- !p1 p2. (p1 ==&gt; p2) ==&gt; (p2 ==&gt; p1) ==&gt; (p1 &lt;=&gt; p2));</span>
<span class="c">//    (&quot;infinity_ax&quot;, |- ?(f:ind-&gt;ind). ONE_ONE f /\ ~ ONTO f);</span>
<span class="c">//    (&quot;select_ax&quot;, |- !(P:&#39;a-&gt;bool) x. P x ==&gt; P ($@ P))]</span>
<span class="c">// </span>
<span class="c">// &gt; </span>
</code></pre>
<p>il sistema è quindi pronto per ricevere i comandi dall'utente.
Questi comandi sono di fatto espressioni F#.</p>
<h2><a name="1-3-Panoramica-d-uso" class="anchor" href="#1-3-Panoramica-d-uso">1.3 Panoramica d'uso</a></h2>
<p>Questa sezione fornisce una breve introduzione a semplici operazioni, incluso come immettere espressioni HOL e come eseguire una semplice dimostrazione.</p>
<p><strong>1.3.1 Termini, Tipi e Teoremi</strong></p>
<p>Le espressioni nel linguaggio HOL sono chiamati termini HOL. I termini sono scritti utilizzando una stringa di caratteri ASCII a cui va applicata la funzione <code>parse_term</code>. Nel momento in cui si immette un termine in una sessione questo viene controllato e ristampato a video.</p>
<p>La sintassi dei termini è semplice e intuitiva Per esempio, il seguente termine significa ''per tutti i numeri naturali <code>x</code>, <code>y</code> e <code>z</code>, se <code>x</code> è minore di <code>y</code> e <code>y</code> è minore di <code>z</code> allora <code>x</code> è minore di <code>z</code>'':</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="s">@&quot;!x y z. x &lt; y /\ y &lt; z ==&gt; x &lt; z&quot;</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs21', 31)" onmouseover="showTip(event, 'fs21', 31)" class="fn">parse_term</span>
</code></pre>
<table class="pre"><tr><td><pre><code>val it: term = `!x y z. x &lt; y /\ y &lt; z ==&gt; x &lt; z`</code></pre></td></tr></table>
<p>Se si immette un termine mal formato si riceverà un messaggio di errore.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="s">&quot;x =&quot;</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs21', 32)" onmouseover="showTip(event, 'fs21', 32)" class="fn">parse_term</span>

<span class="c">// &gt; </span>
<span class="c">// HOL.Exn+HolErr: [HZ] SYNTAX ERROR: Unexpected end of quotation instead of RHS for infix &quot;=&quot;</span>
<span class="c">// ...</span>
</code></pre>
<p>Si noti che i messaggi specifici del sistema, diversamente da quelli che derivano dall'interprete F#, in generale, hanno il prefisso `[HZ]'. Questo vale per tutti i messaggi riportati da NHOLZ, inclusi messaggi di errore, warnings e feedback generici all'utente.</p>
<p>HOL è un linguaggio tipizzato, così ogni termine e sottotermine ha un tipo, e i termini devono essere costruiti in modo da avere un tipo corretto. Questo impedisce la costruzione di enunciati privi di significato come ''3 è uguale a vero''.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="s">&quot;3 = true&quot;</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs21', 33)" onmouseover="showTip(event, 'fs21', 33)" class="fn">parse_term</span>
<span class="c">// &gt; </span>
<span class="c">// HOL.Exn+HolErr: [HZ] TYPE ERROR: Function subterm domain type incompatible with argument subterm type</span>
</code></pre>
<p>I sottotermini possono essere annotati per indicare il loro tipo, facendo seguire al sottotermine il simbolo di due punti <code>:</code> e poi il suo tipo, il tutto chiuso tra parentesi. Il meccanismo di inferenza del tipo è usato per risolvere i tipi nei termini. Ad ogni termine inserito senza annotazioni di tipo sufficienti sono assegnate delle variabili di tipo numerate per tutti i tipi non determinabili. Di default i termini sono ristampati indietro con solamente le annotazioni di tipo sufficienti per evitare qualsiasi ambiguità circa i tipi di ogni sottotermine.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="s">&quot;!(w:nat) (x:nat) y z. w = x /\ y = z&quot;</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs21', 34)" onmouseover="showTip(event, 'fs21', 34)" class="fn">parse_term</span>
</code></pre>
<table class="pre"><tr><td><pre><code>val it: term = `!(w:nat) x (y:'1) z. w = x /\ y = z`</code></pre></td></tr></table>
<p>I tipi HOL possono essere scritti fuori dal contesto di un termine usando la funzone <code>parse_type</code>.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="s">&quot;nat#nat-&gt;bool&quot;</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs22', 35)" onmouseover="showTip(event, 'fs22', 35)" class="fn">parse_type</span>
</code></pre>
<table class="pre"><tr><td><pre><code>val it: hol_type = `:nat#nat-&gt;bool`</code></pre></td></tr></table>
<h2><a name="1-3-2-Teoremi-Dimostrazioni-ed-Asserzioni" class="anchor" href="#1-3-2-Teoremi-Dimostrazioni-ed-Asserzioni">1.3.2 Teoremi, Dimostrazioni ed Asserzioni</a></h2>
<p>I teoremi HOL consistono di un insieme di termini di assunzione con valore booleano e di un termine conclusione con valore booleano, e sono riservati ad enunciati di cui si è stabilito che valgono (per dimostrazione o asserzione - si veda sotto). Il significato di tali enunciati è che la conclusione vale assumendo che valgano tutte le assunzioni. I teoremi sono mostrati usando un turnstile (<code>|-</code>) per separare tutte le assunzioni dalla conclusione. Il sistema di base contiene già oltre 100 teoremi pre-dimostrati, ognuno dei quali non ha assunzione. Questi sono elencati nella sezione <a href="005-Teoremi.html">Teoremi</a>.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs23', 36)" onmouseover="showTip(event, 'fs23', 36)" class="id">excluded_middle_thm</span>
</code></pre>
<table class="pre"><tr><td><pre><code>val it: thm = |- !p. p \/ ~ p</code></pre></td></tr></table>
<p>Le regole di inferenza della logica HOL sono qui implementate come funzioni F# che prendono teoremi e/o termini e restituiscono teoremi. Un passo di dimostrazione è eseguito semplicemente valutando l'applicazione di una tale funzione. Dettagli sulle regole d'inferenza sono forniti nella sezione <a href="003-Inference_Rules.html">Regole d'inferenza</a></p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="s">&quot;x + y &lt; 5&quot;</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs21', 37)" onmouseover="showTip(event, 'fs21', 37)" class="fn">parse_term</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs24', 38)" onmouseover="showTip(event, 'fs24', 38)" class="fn">assume_rule</span>
<span class="c">// val it : thm = x + y &lt; 5 |- x + y &lt; 5</span>

<span onmouseout="hideTip(event, 'fs25', 39)" onmouseover="showTip(event, 'fs25', 39)" class="fn">spec_rule</span> <span class="pn">(</span><span class="s">&quot;a = 0&quot;</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs21', 40)" onmouseover="showTip(event, 'fs21', 40)" class="fn">parse_term</span><span class="pn">)</span> <span onmouseout="hideTip(event, 'fs23', 41)" onmouseover="showTip(event, 'fs23', 41)" class="id">excluded_middle_thm</span>
<span class="c">// val it : thm = |- a = 0 \/ ~ (a = 0)</span>
</code></pre>
<p>Le dimostrazioni sono semplicemente espressioni F# composte con applicazioni di regole di inferenza ad ogni livello.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs26', 42)" onmouseover="showTip(event, 'fs26', 42)" class="fn">deduct_antisym_rule</span>
    <span class="pn">(</span><span onmouseout="hideTip(event, 'fs27', 43)" onmouseover="showTip(event, 'fs27', 43)" class="fn">contr_rule</span> <span class="pn">(</span><span class="s">&quot;~ true&quot;</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs21', 44)" onmouseover="showTip(event, 'fs21', 44)" class="fn">parse_term</span><span class="pn">)</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs24', 45)" onmouseover="showTip(event, 'fs24', 45)" class="fn">assume_rule</span> <span class="pn">(</span><span class="s">&quot;false&quot;</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs21', 46)" onmouseover="showTip(event, 'fs21', 46)" class="fn">parse_term</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span>
    <span class="pn">(</span><span onmouseout="hideTip(event, 'fs28', 47)" onmouseover="showTip(event, 'fs28', 47)" class="fn">eq_mp_rule</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs29', 48)" onmouseover="showTip(event, 'fs29', 48)" class="fn">eqf_intro_rule</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs24', 49)" onmouseover="showTip(event, 'fs24', 49)" class="fn">assume_rule</span> <span class="pn">(</span><span class="s">&quot;~ true&quot;</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs21', 50)" onmouseover="showTip(event, 'fs21', 50)" class="fn">parse_term</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span> <span onmouseout="hideTip(event, 'fs30', 51)" onmouseover="showTip(event, 'fs30', 51)" class="id">truth_thm</span><span class="pn">)</span>
<span class="c">// val it : thm = |- ~ true &lt;=&gt; false</span>
</code></pre>
<p>il sistema supporta le seguenti teorie matematiche di base: logica predicativa, lambda calcolo, coppie ordinate e aritmetica dei numeri naturali. Dettagli circa ogni teoria sono forniti nella sezione <a href="004-Teorie.html">Teorie</a>.</p>
<p>Le teorie del sistema possono essere estese usando i comandi di teoria per dichiarare nuove costanti e costanti di tipo e per enunciare proposizioni a loro riguardo. Per esempio, il comando di definizione di costante introduce una nuova costante e restituisce un nuovo teorema, che afferma che il valore della costante è uguale a un'espressione data. Prende un termine di uguaglianza con la nuova costante come lato sinistro del'eguaglianza e il valore della costante come lato destro. Dettagli su ciascun comendo di teoria sono forniti nella sezione <a href="004-Teorie.html">Teorie</a>.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="s">&quot;max_height = 7&quot;</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs21', 52)" onmouseover="showTip(event, 'fs21', 52)" class="fn">parse_term</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs31', 53)" onmouseover="showTip(event, 'fs31', 53)" class="fn">new_const_definition</span>
<span class="c">// [HZ] Declaring constant &quot;max_height&quot;.</span>
<span class="c">// [HZ] Adding definition for constant &quot;max_height&quot;.</span>
<span class="c">// val it : thm = |- max_height = 7</span>
</code></pre>

                </div>
            </div>
        </div>
        <div class="fsdocs-tip" id="fs1">namespace HOL</div>
<div class="fsdocs-tip" id="fs2">val print_type: ty: hol_type -&gt; string</div>
<div class="fsdocs-tip" id="fs3">val print_qtype: ty: hol_type -&gt; string</div>
<div class="fsdocs-tip" id="fs4">val print_term: tm: term -&gt; string</div>
<div class="fsdocs-tip" id="fs5">val print_qterm: tm: term -&gt; string</div>
<div class="fsdocs-tip" id="fs6">val print_thm: th: thm -&gt; string</div>
<div class="fsdocs-tip" id="fs7">module CoreThry

from HOL<br /><em>&lt;summary&gt;
This module completes the logical core for HOL by defining the core       
theory.  This involves giving declarations, definitions and axioms for all
the HOL theory objects anticipated by the language and inference kernels. 
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs8">val load: (string * thm) list</div>
<div class="fsdocs-tip" id="fs9">module Equal

from HOL<br /><em>&lt;summary&gt;
This module adds more constants and inference rules for basic reasoning
using equality.                                                                                                       
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs10">val load: (string * thm) list<br /><em>&lt;summary&gt;
 Force module evaluation
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs11">module Bool

from HOL<br /><em>&lt;summary&gt;
This module extends the boolean-related theory by giving definitions for  
classic predicate logic theory objects not introduced in &#39;CoreThry&#39;, and  
adds various derived syntax functions, theorems and inference rules.  Note
that derivations relying on the Axiom of Choice are separated out into the
&#39;BoolClass&#39; module.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs12">module BoolAlg

from HOL<br /><em>&lt;summary&gt;
This module proves various algebraic property theorems for the predicate
logic operators.                                                                  
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs13">module BoolClass

from HOL<br /><em>&lt;summary&gt;
 This module derives further predicate logic theorems and inference rules.
 Unlike all preceding derivations, these all use the Axiom of Choice (i.e.
 &#39;select_ax&#39;), and thus could be considered as classical logic.  However, 
 note that some of these (such as &#39;exists_rule&#39;) are actually derivable in
 intuitionistic logic if an alternative definition of existential         
 quantification is used (as in HOL Light).                                                                                        
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs14">module Pair

from HOL<br /><em>&lt;summary&gt;
 This module extends the HOL logic with the theory of ordered pairs.  This 
 involves giving theory object definitions for the product type operator,  
 the pairing function and the constants &quot;FST&quot; and &quot;SND&quot;, and proving a few 
 basic properties.  Syntax functions and equality congruence rules are also
 provided.                                                                                                                                                                                          
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs15">module Ind

from HOL<br /><em>&lt;summary&gt;
This module extends the HOL logic with an infinite-cardinality base type,
together with a zero and a successor function for this type.  These get  
used in the &#39;Nat&#39; module as the basis for defining the natural numbers.                                                                                                                                                                     
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs16">module Nat

from HOL<br /><em>&lt;summary&gt;
This module extends the HOL logic with the theory of natural numbers.    
This involves giving theory object definitions for the naturals base type
and the &quot;ZERO&quot; and &quot;SUC&quot; constants, based on the theory of individuals,  
and proving a few important properties.                                                                                                                                                                                                      
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs17">module NatNumrl

from HOL<br /><em>&lt;summary&gt;
This module defines the representation of natural number numerals.  This
is based on the HOL functions &quot;BIT0&quot; and &quot;BIT1&quot;.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs18">module NatArith

from HOL<br /><em>&lt;summary&gt;
This module defines some classic natural number arithmetic operators,  
using recursive function definition and the &quot;SUC&quot; and &quot;ZERO&quot; constants,
and proves various basic properties about each operator.               
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs19">module NatRel

from HOL<br /><em>&lt;summary&gt;
This module defines the classic natural number arithmetic relations and
derives various basic properties about them.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs20">module NatEval

from HOL<br /><em>&lt;summary&gt;
This module defines conversions for evaluating arithmetic operations on 
natual number numerals.  Because large proofs may involve heavy numeric 
computation, special consideration is given to the efficieny of these   
functions.                                                              
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs21">val parse_term: x: string -&gt; term<br /><em>&lt;summary&gt;
 This takes a string and parses it into an internal term.  The type     
 analysis stage first detypes the preterm before inferring types (in    
 &#39;resolve_preterm&#39;), since the syntax analysis stage gives all variables
 and constants the null pretype.  Note that type inference is capable of
 handling overloaded variables.                                         
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs22">val parse_type: x: string -&gt; hol_type</div>
<div class="fsdocs-tip" id="fs23">val excluded_middle_thm: thm<br /><em>&lt;summary&gt;
    |- !p. p \/ ~p
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs24">val assume_rule: tm: term -&gt; thm<br /><em>&lt;summary&gt;
 This is the assumption rule.  It takes a boolean term, and returns a theorem
 stating that the term holds under the single assumption of the term itself.

     `p`
   --------
   {p} |- p
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs25">val spec_rule: tm: term -&gt; th: thm -&gt; thm<br /><em>&lt;summary&gt;
 This is the universal elimination rule.  It strips off the outermost     
 universal quantifier from the supplied theorem, and replaces in the body 
 each occurrence of the stripped binding variable with the supplied term. 
 The type of the supplied term must equal the type of the stripped binding
 variable.                                                                
                                                                          
    `t`   A |- !x. p                                                      
    ----------------                                                      
      A |- p[t/x]                                                         
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs26">val deduct_antisym_rule: th01: thm -&gt; th02: thm -&gt; thm<br /><em>&lt;summary&gt;
 This is the antisymmetry rule for deduction.  It takes two theorem        
 arguments.  It returns a theorem stating that the supplied conclusions are
 equivalent, under the unioned assumptions but with each theorem&#39;s         
 conclusion removed from the other&#39;s assumptions.                          
                                                                           
        A1 |- p    A2 |- q      
    --------------------------              
    A1\{q} u A2\{p} |- p &amp;lt;=&amp;gt; q                      

 See also: imp_antisym_rule, undisch_rule.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs27">val contr_rule: tm: term -&gt; th: thm -&gt; thm<br /><em>&lt;summary&gt;
 This is the intuitionistic contradiction rule.  It takes a boolean term   
 and a theorem with falsity as its conclusion.  It returns a theorem with  
 the supplied term as its conclusion, under the same assumptions as the    
 supplied theorem.                                                         
                                                                           
    `p`   A |- false                                                       
    ----------------                                                       
         A |- p                                               

 See also: ccontr_rule, deduct_contrapos_rule.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs28">val eq_mp_rule: th1: thm -&gt; th2: thm -&gt; thm<br /><em>&lt;summary&gt;
 This is the equality modus ponens rule.  It takes an equality theorem and a
 second theorem, where the equality theorem&#39;s LHS is alpha-equivalent to the
 conclusion of the second theorem.  It returns a theorem stating that the
 equality theorem&#39;s RHS holds, under the unioned assumptions of the supplied
 theorems.
 
       A1 |- p &amp;lt;=&amp;gt; q    A2 |- p
       ------------------------
             A1 u A2 |- q
 
 See also: mp_rule, eq_imp_rule1, eq_imp_rule2, imp_antisym_rule.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs29">val eqf_intro_rule: th: thm -&gt; thm<br /><em>&lt;summary&gt;
 This is the falsity equivalence introduction rule.  It takes a theorem    
 with logical negation at its top level, and returns a theorem stating that
 the body of the negation is equivalent to falsity, under the same         
 assumptions.                                                              
                                                                           
        A |- ~ p                                                           
    ----------------                                                       
    A |- p &amp;lt;=&amp;gt; false                                                       

 See also: eqf_elim_rule, not_elim_rule, not_intro_rule, mk_not_rule,
 eqt_intro_rule.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs30">val truth_thm: thm<br /><em>&lt;summary&gt;
 |- true
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs31">val new_const_definition: tm: term -&gt; thm</div>

    </div>

    <!-- BEGIN SEARCH BOX: this adds support for the search box -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/JavaScript-autoComplete/1.0.4/auto-complete.css" />
    <script type="text/javascript">var fsdocs_search_baseurl = '/nholz/'</script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.8/lunr.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/JavaScript-autoComplete/1.0.4/auto-complete.min.js"></script>
    <script type="text/javascript" src="/nholz/content/fsdocs-search.js"></script>
    <!-- END SEARCH BOX: this adds support for the search box -->
</body>

</html>