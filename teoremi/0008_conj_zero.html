<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>congiunzione zero
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="author" content="nholz">
    <link rel="shortcut icon" type="image/x-icon" href="/nholz//img/favicon.ico">
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script> -->

    <link type="text/css" rel="stylesheet" href="/nholz/content/fsdocs-default.css" />
    <link type="text/css" rel="stylesheet" href="/nholz/content/fsdocs-custom.css" />
    <script type="text/javascript" src="/nholz/content/fsdocs-tips.js"></script>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!-- BEGIN SEARCH BOX: this adds support for the search box -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/JavaScript-autoComplete/1.0.4/auto-complete.css" />
    <!-- END SEARCH BOX: this adds support for the search box -->
    
</head> 

<body>
    <div class="columns is-fullheight m-0">
        <div id="fsdocs-menu" class="column is-2 is-paddingless">
            <aside class="menu">
                <div class="container is-paddingless is-marginless has-background-dark">
                    <a href="/nholz/">
                        <figure class="image is-128x128 container">
                            <img src="/nholz/img/logo.png">
                        </figure>
                    </a>
                    <h2 class="title has-text-centered has-text-white pb-4">nholz</h2>
                </div>
                <div class="content">
                    <!-- BEGIN SEARCH BOX: this adds support for the search box -->
                    <div id="header">
                        <div class="searchbox" id="fsdocs-searchbox">
                            <label for="search-by">
                                <i class="fas fa-search"></i>
                            </label>
                            <input data-search-input="" id="search-by" type="search" placeholder="Search..." class="input"/>
                            <span data-search-clear="">
                                <i class="fas fa-times"></i>
                            </span>
                        </div>
                    </div>
                    <!-- END SEARCH BOX: this adds support for the search box -->
                    <ul class="navbar-nav">
                        <li class="nav-header">Links</li>
                        <li class="nav-item" id="fsdocs-license-link"><a class="nav-link" href="{{fsdocs-license-link}}">License (MIT)</a></li>
                        <li class="nav-item" id="fsdocs-release-notes-link"><a class="nav-link" href="{{fsdocs-release-notes-link}}">Release Notes</a></li>
                        <li class="nav-item" id="fsdocs-repository-link"><a class="nav-link" href="{{fsdocs-repository-link}}">Source Repository</a></li>
                        <li class="nav-header">Il sistema HOL</li>
                        <li class="nav-item" id="index-link"><a class="nav-link" href="/index.html">Indice</a></li>
                        <li class="nav-header">
  API Reference
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/reference/index.html">
    All Namespaces
  </a>
</li>
                    </ul>
                </div>
            </aside>
        </div>
        <div class="column is-10 is-paddingless">
            <div class="section pt-4">
                <div class="container" id="fsdocs-content">
                    <h1><a name="congiunzione-zero" class="anchor" href="#congiunzione-zero">congiunzione zero</a></h1>
<p><span class="math">\(\forall p.\ p \wedge \bot \Leftrightarrow \bot\)</span></p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs7', 8)" onmouseover="showTip(event, 'fs7', 8)" class="id">conj_zero_thm</span>
<span class="c">//   |- !p. p /\ false &lt;=&gt; false</span>
</code></pre>
<p>Backward proof with tree</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="pn">(</span><span class="pn">[</span><span class="pn">]</span><span class="pn">,</span><span class="s">&quot;!p. p /\ false &lt;=&gt; false&quot;</span><span class="pn">)</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs8', 9)" onmouseover="showTip(event, 'fs8', 9)" class="fn">start_proof</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 10)" onmouseover="showTip(event, 'fs9', 10)" class="fn">gen_rule_bk</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs10', 11)" onmouseover="showTip(event, 'fs10', 11)" class="fn">deduct_antisym_rule_bk</span> <span class="pn">[</span><span class="pn">]</span> <span class="pn">[</span><span class="pn">]</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs11', 12)" onmouseover="showTip(event, 'fs11', 12)" class="fn">contr_rule_bk</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs12', 13)" onmouseover="showTip(event, 'fs12', 13)" class="fn">assume_rule_bk</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs13', 14)" onmouseover="showTip(event, 'fs13', 14)" class="fn">conjunct2_rule_bk</span> <span class="s">&quot;p:bool&quot;</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs12', 15)" onmouseover="showTip(event, 'fs12', 15)" class="fn">assume_rule_bk</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs14', 16)" onmouseover="showTip(event, 'fs14', 16)" class="fn">view</span>
</code></pre>
<p><span class="math">\(\small{ 	\color{green}{\dfrac
{p:bool
\qquad
\color{green}{\dfrac
{\color{green}{\dfrac
{p\ \wedge\ \bot
\qquad
\color{green}{\dfrac
{\bot}
{\bot\ \vdash\ \bot}
\textsf{ assume_rule}}}
{\bot\ \vdash\ p\ \wedge\ \bot}
\textsf{ contr_rule}}
\qquad
\color{green}{\dfrac
{\color{green}{\dfrac
{p\ \wedge\ \bot}
{p\ \wedge\ \bot\ \vdash\ p\ \wedge\ \bot}
\textsf{ assume_rule}}}
{p\ \wedge\ \bot\ \vdash\ \bot}
\textsf{ conjunct2_rule}}}
{\vdash\ p\ \wedge\ \bot\ \Leftrightarrow\ \bot}
\textsf{ deduct_antisym_rule}}}
{\vdash\ \forall\ p.\ p\ \wedge\ \bot\ \Leftrightarrow\ \bot}
\textsf{ gen_rule}} }\)</span></p>
<p>Forward proof with tree</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs15', 17)" onmouseover="showTip(event, 'fs15', 17)" class="fn">gen_rule_fd</span> <span onmouseout="hideTip(event, 'fs16', 18)" onmouseover="showTip(event, 'fs16', 18)" class="id">p</span>
    <span class="pn">(</span><span onmouseout="hideTip(event, 'fs17', 19)" onmouseover="showTip(event, 'fs17', 19)" class="fn">deduct_antisym_rule_fd</span>
      <span class="pn">(</span><span onmouseout="hideTip(event, 'fs18', 20)" onmouseover="showTip(event, 'fs18', 20)" class="fn">contr_rule_fd</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs19', 21)" onmouseover="showTip(event, 'fs19', 21)" class="fn">parse_term</span><span class="pn">(</span><span class="s">@&quot;p /\ false&quot;</span><span class="pn">)</span><span class="pn">)</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs20', 22)" onmouseover="showTip(event, 'fs20', 22)" class="fn">assume_rule_fd</span> <span onmouseout="hideTip(event, 'fs21', 23)" onmouseover="showTip(event, 'fs21', 23)" class="id">false_tm</span><span class="pn">)</span><span class="pn">)</span>
      <span class="pn">(</span><span onmouseout="hideTip(event, 'fs22', 24)" onmouseover="showTip(event, 'fs22', 24)" class="fn">conjunct2_rule_fd</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs20', 25)" onmouseover="showTip(event, 'fs20', 25)" class="fn">assume_rule_fd</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs19', 26)" onmouseover="showTip(event, 'fs19', 26)" class="fn">parse_term</span><span class="pn">(</span><span class="s">@&quot;p /\ false&quot;</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span> <span class="pn">)</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs23', 27)" onmouseover="showTip(event, 'fs23', 27)" class="fn">zipper</span>
<span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs14', 28)" onmouseover="showTip(event, 'fs14', 28)" class="fn">view</span>
</code></pre>
<p>Classic forward proof without tree</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs24', 29)" onmouseover="showTip(event, 'fs24', 29)" class="fn">gen_rule</span> <span onmouseout="hideTip(event, 'fs16', 30)" onmouseover="showTip(event, 'fs16', 30)" class="id">p</span>
    <span class="pn">(</span><span onmouseout="hideTip(event, 'fs25', 31)" onmouseover="showTip(event, 'fs25', 31)" class="fn">deduct_antisym_rule</span>
      <span class="pn">(</span><span onmouseout="hideTip(event, 'fs26', 32)" onmouseover="showTip(event, 'fs26', 32)" class="fn">contr_rule</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs19', 33)" onmouseover="showTip(event, 'fs19', 33)" class="fn">parse_term</span><span class="pn">(</span><span class="s">@&quot;p /\ false&quot;</span><span class="pn">)</span><span class="pn">)</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs27', 34)" onmouseover="showTip(event, 'fs27', 34)" class="fn">assume_rule</span> <span onmouseout="hideTip(event, 'fs21', 35)" onmouseover="showTip(event, 'fs21', 35)" class="id">false_tm</span><span class="pn">)</span><span class="pn">)</span>
      <span class="pn">(</span><span onmouseout="hideTip(event, 'fs28', 36)" onmouseover="showTip(event, 'fs28', 36)" class="fn">conjunct2_rule</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs27', 37)" onmouseover="showTip(event, 'fs27', 37)" class="fn">assume_rule</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs19', 38)" onmouseover="showTip(event, 'fs19', 38)" class="fn">parse_term</span><span class="pn">(</span><span class="s">@&quot;p /\ false&quot;</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span> <span class="pn">)</span>
</code></pre>

                </div>
            </div>
        </div>
        <div class="fsdocs-tip" id="fs1">namespace HOL</div>
<div class="fsdocs-tip" id="fs2">module CoreThry

from HOL<br /><em>&lt;summary&gt;
This module completes the logical core for HOL by defining the core       
theory.  This involves giving declarations, definitions and axioms for all
the HOL theory objects anticipated by the language and inference kernels. 
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs3">val load: (string * thm) list</div>
<div class="fsdocs-tip" id="fs4">module Equal

from HOL<br /><em>&lt;summary&gt;
This module adds more constants and inference rules for basic reasoning
using equality.                                                                                                       
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs5">val load: (string * thm) list<br /><em>&lt;summary&gt;
 Force module evaluation
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs6">module Bool

from HOL<br /><em>&lt;summary&gt;
This module extends the boolean-related theory by giving definitions for  
classic predicate logic theory objects not introduced in &#39;CoreThry&#39;, and  
adds various derived syntax functions, theorems and inference rules.  Note
that derivations relying on the Axiom of Choice are separated out into the
&#39;BoolClass&#39; module.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs7">val conj_zero_thm: thm<br /><em>&lt;summary&gt;
 |- !p. p /\ false &amp;lt;=&amp;gt; false
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs8">val start_proof: xs: string list * s: string -&gt; Proof Location</div>
<div class="fsdocs-tip" id="fs9">val gen_rule_bk: loc: (Exp * string * InfRule) Location -&gt; (Exp * string * InfRule) Location</div>
<div class="fsdocs-tip" id="fs10">val deduct_antisym_rule_bk: ind1: int list -&gt; ind2: int list -&gt; loc: (Exp * string * InfRule) Location -&gt; (Exp * string * InfRule) Location</div>
<div class="fsdocs-tip" id="fs11">val contr_rule_bk: loc: (Exp * string * InfRule) Location -&gt; (Exp * string * InfRule) Location</div>
<div class="fsdocs-tip" id="fs12">val assume_rule_bk: loc: Proof Location -&gt; Proof Location</div>
<div class="fsdocs-tip" id="fs13">val conjunct2_rule_bk: t1: string -&gt; loc: Proof Location -&gt; Proof Location</div>
<div class="fsdocs-tip" id="fs14">val view: loc: Proof Location -&gt; Proof Location</div>
<div class="fsdocs-tip" id="fs15">val gen_rule_fd: (term -&gt; Proof Tree -&gt; Proof Tree)</div>
<div class="fsdocs-tip" id="fs16">val p: term</div>
<div class="fsdocs-tip" id="fs17">val deduct_antisym_rule_fd: t1: Proof Tree -&gt; t2: Proof Tree -&gt; Proof Tree</div>
<div class="fsdocs-tip" id="fs18">val contr_rule_fd: (term -&gt; Proof Tree -&gt; Proof Tree)</div>
<div class="fsdocs-tip" id="fs19">val parse_term: x: string -&gt; term<br /><em>&lt;summary&gt;
 This takes a string and parses it into an internal term.  The type     
 analysis stage first detypes the preterm before inferring types (in    
 &#39;resolve_preterm&#39;), since the syntax analysis stage gives all variables
 and constants the null pretype.  Note that type inference is capable of
 handling overloaded variables.                                         
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs20">val assume_rule_fd: t: term -&gt; Proof Tree</div>
<div class="fsdocs-tip" id="fs21">val false_tm: term</div>
<div class="fsdocs-tip" id="fs22">val conjunct2_rule_fd: (Proof Tree -&gt; Proof Tree)</div>
<div class="fsdocs-tip" id="fs23">val zipper: t: &#39;a Tree -&gt; &#39;a Location</div>
<div class="fsdocs-tip" id="fs24">val gen_rule: v: term -&gt; th: thm -&gt; thm<br /><em>&lt;summary&gt;
 gen_rule : term -&amp;gt; thm -&amp;gt; thm                                             
                                                                           
 This is the universal introduction rule.  It universally quantifies the   
 supplied theorem with the supplied binding variable, under the same       
 assumptions.  The binding variable must not occur free in the assumptions.
                                                                           
    `x`   A |- p         [ &quot;x&quot; not free in `A` ]                           
    ------------                                                           
     A |- !x. p                                                            

 See also: list_gen_rule, spec_rule, mk_forall_rule.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs25">val deduct_antisym_rule: th01: thm -&gt; th02: thm -&gt; thm<br /><em>&lt;summary&gt;
 This is the antisymmetry rule for deduction.  It takes two theorem        
 arguments.  It returns a theorem stating that the supplied conclusions are
 equivalent, under the unioned assumptions but with each theorem&#39;s         
 conclusion removed from the other&#39;s assumptions.                          
                                                                           
        A1 |- p    A2 |- q      
    --------------------------              
    A1\{q} u A2\{p} |- p &amp;lt;=&amp;gt; q                      

 See also: imp_antisym_rule, undisch_rule.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs26">val contr_rule: tm: term -&gt; th: thm -&gt; thm<br /><em>&lt;summary&gt;
 This is the intuitionistic contradiction rule.  It takes a boolean term   
 and a theorem with falsity as its conclusion.  It returns a theorem with  
 the supplied term as its conclusion, under the same assumptions as the    
 supplied theorem.                                                         
                                                                           
    `p`   A |- false                                                       
    ----------------                                                       
         A |- p                                               

 See also: ccontr_rule, deduct_contrapos_rule.
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs27">val assume_rule: tm: term -&gt; thm<br /><em>&lt;summary&gt;
 This is the assumption rule.  It takes a boolean term, and returns a theorem
 stating that the term holds under the single assumption of the term itself.

     `p`
   --------
   {p} |- p
&lt;/summary&gt;</em></div>
<div class="fsdocs-tip" id="fs28">val conjunct2_rule: th: thm -&gt; thm<br /><em>&lt;summary&gt;
 This is the conjunction elimination rule for the RHS.  It removes the LHS  
 conjunct from the supplied conjunction theorem.                            
                                                                            
    A |- p /\ q                                                             
    -----------                                                             
      A |- q                                                               

 See also: conjunct1_rule, conjunct_rule, mk_conj_rule.
&lt;/summary&gt;</em></div>

    </div>

    <!-- BEGIN SEARCH BOX: this adds support for the search box -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/JavaScript-autoComplete/1.0.4/auto-complete.css" />
    <script type="text/javascript">var fsdocs_search_baseurl = '/nholz/'</script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.8/lunr.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/JavaScript-autoComplete/1.0.4/auto-complete.min.js"></script>
    <script type="text/javascript" src="/nholz/content/fsdocs-search.js"></script>
    <!-- END SEARCH BOX: this adds support for the search box -->
</body>

</html>