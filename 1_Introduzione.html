<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Introduzione
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="author" content="">
    <link rel="shortcut icon" type="image/x-icon" href="/nholz//img/favicon.ico">
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script> -->

    <link type="text/css" rel="stylesheet" href="/nholz/content/fsdocs-default.css" />
    <link type="text/css" rel="stylesheet" href="/nholz/content/fsdocs-custom.css" />
    <script type="text/javascript" src="/nholz/content/fsdocs-tips.js"></script>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!-- BEGIN SEARCH BOX: this adds support for the search box -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/JavaScript-autoComplete/1.0.4/auto-complete.css" />
    <!-- END SEARCH BOX: this adds support for the search box -->
    
</head> 

<body>
    <div class="columns is-fullheight m-0">
        <div id="fsdocs-menu" class="column is-2 is-paddingless">
            <aside class="menu">
                <div class="container is-paddingless is-marginless has-background-dark">
                    <a href="/nholz/">
                        <figure class="image is-128x128 container">
                            <img src="/nholz/img/logo.png">
                        </figure>
                    </a>
                    <h2 class="title has-text-centered has-text-white pb-4">nholz</h2>
                </div>
                <div class="content">
                    <!-- BEGIN SEARCH BOX: this adds support for the search box -->
                    <div id="header">
                        <div class="searchbox" id="fsdocs-searchbox">
                            <label for="search-by">
                                <i class="fas fa-search"></i>
                            </label>
                            <input data-search-input="" id="search-by" type="search" placeholder="Search..." class="input"/>
                            <span data-search-clear="">
                                <i class="fas fa-times"></i>
                            </span>
                        </div>
                    </div>
                    <!-- END SEARCH BOX: this adds support for the search box -->
                    <ul class="navbar-nav">
                        <li class="nav-header">Links</li>
                        <li class="nav-item" id="fsdocs-license-link"><a class="nav-link" href="{{fsdocs-license-link}}">License (MIT)</a></li>
                        <li class="nav-item" id="fsdocs-release-notes-link"><a class="nav-link" href="{{fsdocs-release-notes-link}}">Release Notes</a></li>
                        <li class="nav-item" id="fsdocs-repository-link"><a class="nav-link" href="{{fsdocs-repository-link}}">Source Repository</a></li>
                        <li class="nav-header">
  Documentation
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/tactics.html">
    tactics
  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/3_Liguaggio_HOL.html">
    LINGUAGGIO HOL

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/avvio.html">
    avvio
  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/B1_Teorie.html">
    TEORIE

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/1_Introduzione.html">
    Introduzione

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/B2_Teoremi.html">
    TEOREMI

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/goaltree.html">
    goaltree
  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/A5_Inference_Rules.html">
    Regole d&#39;inferenza

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0018_disj_idem.html">
    Disj Idem

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0033_select_eq.html">
    0033_select_eq
  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0032_forall_null.html">
    0032_forall_null
  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0001_truth.html">
    Vero

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0019_disj_assoc.html">
    0019_disj_assoc
  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0007_conj_id.html">
    vero &amp;egrave; l&#39;identit&amp;agrave; della congiunzione

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0028_imp_dist_left_disj.html">
    0028_imp_dist_left_disj
  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0021_disj_dist_right_conj.html">
    0021_disj_dist_right_conj
  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0017_disj_zero.html">
    Disj Zero

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0010_conj_comm.html">
    Propriet&amp;agrave; commutatativa della congiuzione

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0031_forall_one_point.html">
    0031_forall_one_point
  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0005_true_not_eq_false.html">
    Vero non equivale a falso

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0027_imp_refl.html">
    0027_imp_refl
  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0008_conj_zero.html">
    congiunzione zero

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0014_conj_dist_left_disj.html">
    distributivit&amp;agrave; a sinistra della congiunzione sulla disgiunzione

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0016_disj_id.html">
    Disj Id

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0015_conj_contr.html">
    0015_conj_contr
  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0012_conj_absorb_disj.html">
    assorbimento della disgiunzione nella congiunzione

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0009_conj_idem.html">
    congiunzione della stessa proposizione

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0030_forall_dist_conj.html">
    0030_forall_dist_conj
  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0026_imp_left_zero.html">
    0026_imp_left_zero
  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0020_disj_absorb_conj.html">
    0020_disj_absorb_conj
  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0036_exists_null.html">
    0036_exists_null
  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0025_imp_left_id.html">
    0025_imp_left_id
  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0029_imp_dist_right_conj.html">
    0029_imp_dist_right_conj
  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0004_not_false.html">
    Non falso equivale a vero

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0034_exists_dist_disj.html">
    0034_exists_dist_disj
  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0024_disj_comm.html">
    commutabilit&amp;agrave; della disgiunzione

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0006_not_dist_disj.html">
    distribuzione della negazione sulla disgiunzione

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0011_conj_assoc.html">
    Propriet&amp;agrave; associativa della congiuzione

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0022_disj_dist_left_conj.html">
    0022_disj_dist_left_conj
  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0003_not_true.html">
    Non vero equivale a falso

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0023_imp_right_zero.html">
    0023_imp_right_zero
  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0013_conj_dist_right_disj.html">
    distributivit&amp;agrave; a destra della congiunzione sulla disgiunzione

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0044_excluded_midle.html">
    Terzo escluso

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0035_exists_one_point.html">
    0035_exists_one_point
  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0045_bool_cases.html">
    Bool Cases

  </a>
</li>             
<li class="nav-item">
  <a class="nav-link" href="/nholz/teoremi/0002_fun_eq.html">
    Equivalenza tra funzioni

  </a>
</li>
                        {{fsdocs-list-of-namespaces}}
                    </ul>
                </div>
            </aside>
        </div>
        <div class="column is-10 is-paddingless">
            <div class="section pt-4">
                <div class="container" id="fsdocs-content">
                    <h1><a name="Introduzione" class="anchor" href="#Introduzione">Introduzione</a></h1>
<p>Questo &egrave; il Manuale Utente di NHOLZ e fornisce una descrizione completa di come usare il sistema.</p>
<h2><a name="1-1-Concetti-Base" class="anchor" href="#1-1-Concetti-Base">1.1 Concetti Base</a></h2>
<p><strong>1.1.1 NHOLZ</strong></p>
<p>NHOLZ &egrave; un porting di HOL Zero in F# che ha lo scopo di avere un dimostratore di teoremi HOL, cio&egrave; un programma
che supporta dimostrazioni formali e lo sviluppo di teorie nella logica HOL (si veda pi&ugrave; avanti), a disposizione in F#
per lo studio a livello personale di sistemi di questo tipo. Si &egrave; scelto HOL Zero come base perch&eacute; &egrave;
un dimostratore di teoremi relativamente semplice che si concentra su buone funzionalit&agrave; di base,
robustezza architetturale, lo sviluppo della sintassi concreta, un prettyprinting completo e non ambiguo, e la
leggibilit&agrave; del codice sorgente e perch&eacute; per le sue caratteristiche &egrave; risultato piuttosto semplice
effettuarne il porting.</p>
<p>NHOLZ non &egrave; adatto allo sviluppo di dimostrazioni di grandi dimensioni. Esso, infatti, supporta soltanto uno
stile di dimostrazione nella semplice deduzione naturale, e manca di funzionalit&agrave; interattive ed automatiche
avanzate che altri sistemi HOL hanno.</p>
<p>L'interazione utente con HOL avviene immettendo istruzioni a riga di comando in formato ASCII in una sessione
interativa F#. Queste istruzioni sono di fatto espressioni nel linguaggio di programmazione che vengono valutate
dall'interprete REPL una volta immesse.</p>
<p>Coloro che hanno una pi&ugrave; profonda conoscenza di F# possono estenderne le funzionalit&agrave;. Una modalit&agrave; di
estensione consiste nell'immettere definizioni in una sessione di NHOLZ (cio&egrave; una sessione interativa F# con il codice
sorgente di NHOLZ incorporata). Qualsiasi di queste estensioni sono sicure nel senso che non possono introdurre incoerenze
logiche nel sistema. Questa sicurezza &egrave; garantita dal fatto che NHOLZ &egrave; implementato secondo quella che viene
chiamata un'architettura nello ''stile LCF'' (si veda la Sessione 4.1.3), che &egrave; usata anche in altri sistemi HOL.</p>
<p><strong>1.1.2 La logica HOL</strong></p>
<p>La logica HOL &egrave; una logica predicativa tipizzata, classica, di ordine superiore, cio&egrave; una logica
predicativa con un sistema di tipi, con la legge del terzo escluso come teorema, e con la possibilit&agrave; di
quantificare su funzioni. E' basata sul lambda calcolo tipizzato di Alonzo Church. Ha un sistema polimorfico di
tipi relativamente semplice che non &egrave; dipendentemente tipizzato e non supporta la quantificazione su
variabili di tipo. Si faccia riferimento al glossario per una spiegazione estesa di questi concetti.</p>
<p>La logica HOL fu sviluppata per la prima volta negli anni 1980 per un sistema prototipo chiamato Cambridge HOL, ed
&egrave; ora supportata dalla famiglia di dimostratori di teoremi HOL che include HOL4, ProofPower HOL, HOL Light
e Isabelle/HOL. Questi sistemi sono stati utilizzati come strumenti affidabili essenziali in una variet&agrave; di
progetti industriali, che includono la verifica dello sviluppo di microcircuiti integrati per computer e software
safety-critical. Essi sono anche preminenti nella formalizzazione della matematica, in particolare nell'innovativo
progetto Flyspeck di Tom Hales per formalizzare la sua dimostrazione della congettura di Keplero.</p>
<p><strong>1.1.3 Common HOL</strong></p>
<p>Common HOL &egrave; uno standard per le funzionalit&agrave; di base di un sistema HOL, che ha lo scopo di facilitare la portabilit&agrave; del codice sorgente
e delle dimostrazioni formali tra i membri della famiglia HOL. Esso consiste nelle seguenti componenti:</p>
<ul>
<li>la specifica di una API di funzionalit&agrave; HOL di base, per permettere il porting del codice sorgente tra sistemi HOL compatibili;</li>
<li>l'implementazione dell'API per vari sistemi HOL;</li>
<li>la specifica di un formato di file di dimostrazione, per permettere il porting delle dimostrazioni formali tra sistemi HOL compatibili;</li>
<li>l'implementazioni di oggetti per l'esportazione e l'importazione delle dimostrazioni tra vari sistemi HOL.</li>
</ul>
<p>NHOLZ, in generale, supporta lo standard Common HOL avendolo ereditato da HOL Zero. Va, tuttavia, notato che non supporta
le term e le type quotation.</p>
<h2><a name="1-2-Avviare-una-sessione" class="anchor" href="#1-2-Avviare-una-sessione">1.2 Avviare una sessione</a></h2>
<p>Una sessione di NHOLZ &egrave; avviata da uno script F#. Innanzitutto &egrave; necessario referenziare la dll
e importare i relativi moduli:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="pp">#I</span> <span class="s">&quot;../src/bin/Debug/net7.0&quot;</span>
<span class="pp">#r</span> <span class="s">&quot;nholz.dll&quot;</span>
<span class="k">open</span> <span class="id">HOL</span>
</code></pre>
<p>impostare il pretty printing delle espressioni:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="id">fsi</span><span class="pn">.</span><span class="id">AddPrinter</span> <span class="id">print_type</span>
<span class="id">fsi</span><span class="pn">.</span><span class="id">AddPrinter</span> <span class="id">print_qtype</span>
<span class="id">fsi</span><span class="pn">.</span><span class="id">AddPrinter</span> <span class="id">print_term</span>
<span class="id">fsi</span><span class="pn">.</span><span class="id">AddPrinter</span> <span class="id">print_qterm</span>
<span class="id">fsi</span><span class="pn">.</span><span class="id">AddPrinter</span> <span class="id">print_thm</span>
</code></pre>
<p>e caricare quindi i moduli con i seguenti comandi:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="id">CoreThry</span><span class="pn">.</span><span class="id">load</span>
<span class="id">Equal</span><span class="pn">.</span><span class="id">load</span>
<span class="id">Bool</span><span class="pn">.</span><span class="id">load</span>
<span class="id">BoolAlg</span><span class="pn">.</span><span class="id">load</span>
<span class="id">BoolClass</span><span class="pn">.</span><span class="id">load</span>
<span class="id">Pair</span><span class="pn">.</span><span class="id">load</span>
<span class="id">Ind</span><span class="pn">.</span><span class="id">load</span>
<span class="id">Nat</span><span class="pn">.</span><span class="id">load</span>
<span class="id">NatNumrl</span><span class="pn">.</span><span class="id">load</span>
<span class="id">NatArith</span><span class="pn">.</span><span class="id">load</span>
<span class="id">NatRel</span><span class="pn">.</span><span class="id">load</span>
<span class="id">NatEval</span><span class="pn">.</span><span class="id">load</span>
</code></pre>
<p>I primi pochi secondi di avvio richiedono il build del sistema da zero. Alcune centinaia di righe di output
scorrono velocemente sullo schermo.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// ...</span>
<span class="c">// [HZ] Storing theorem &quot;sub_floor_thm&quot;.</span>
<span class="c">// [HZ] Setting term fixity for name &quot;&gt;&quot;.</span>
<span class="c">// [HZ] Declaring constant &quot;&gt;&quot;.</span>
<span class="c">// [HZ] Adding definition for constant &quot;&gt;&quot;.</span>
<span class="c">// [HZ] Setting term fixity for name &quot;&gt;=&quot;.</span>
<span class="c">// [HZ] Declaring constant &quot;&gt;=&quot;.</span>
<span class="c">// [HZ] Adding definition for constant &quot;&gt;=&quot;.</span>
<span class="c">// val it : (string * thm) list =</span>
<span class="c">//   [(&quot;eta_ax&quot;, |- !(f:&#39;a-&gt;&#39;b). (\x. f x) = f);</span>
<span class="c">//    (&quot;imp_antisym_ax&quot;, |- !p1 p2. (p1 ==&gt; p2) ==&gt; (p2 ==&gt; p1) ==&gt; (p1 &lt;=&gt; p2));</span>
<span class="c">//    (&quot;infinity_ax&quot;, |- ?(f:ind-&gt;ind). ONE_ONE f /\ ~ ONTO f);</span>
<span class="c">//    (&quot;select_ax&quot;, |- !(P:&#39;a-&gt;bool) x. P x ==&gt; P ($@ P))]</span>
<span class="c">// </span>
<span class="c">// &gt; </span>
</code></pre>
<p>il sistema è quindi pronto per ricevere i comandi dall'utente.
Questi comandi sono di fatto espressioni F#.</p>
<h2><a name="1-3-Panoramica-d-uso" class="anchor" href="#1-3-Panoramica-d-uso">1.3 Panoramica d'uso</a></h2>
<p>Questa sezione fornisce una breve introduzione a semplici operazioni, incluso come immettere espressioni
HOL e come eseguire una semplice dimostrazione. Per informazioni pi&ugrave; approfondite,
il lettore dovrebbe procedere nei capitoli seguenti del manuale.</p>
<p><strong>1.3.1 Termini, Tipi e Teoremi</strong></p>
<p>Le espressioni nel linguaggio HOL sono chiamati termini HOL. I termini sono scritti utilizzando una stringa di caratteri
ASCII a cui va applicata la funzione <code>parse_term</code>. Nel momento in cui si immette un termine in una sessione
questo viene controllato e ristampato a video.</p>
<p>La sintassi dei termini &egrave; semplice e intuitiva, e si va incontro a vari meccanismi sintattici.
Per esempio, il seguente termine significa ''per tutti i numeri naturali <code>x</code>, <code>y</code> e <code>z</code>, se <code>x</code> &egrave;
minore di <code>y</code> e <code>y</code> &egrave; minore di <code>z</code> allora <code>x</code> &egrave; minore di <code>z</code>'':</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="s">@&quot;!x y z. x &lt; y /\ y &lt; z ==&gt; x &lt; z&quot;</span> <span class="o">|&gt;</span> <span class="id">parse_term</span>
</code></pre>
<table class="pre"><tr><td><pre><code>input.fsx (1,40)-(1,50) typecheck error The value or constructor 'parse_term' is not defined.</code></pre></td></tr></table>
<p>Se si immette un termine mal formato si ricever&agrave; un messaggio di errore.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="s">&quot;x =&quot;</span> <span class="o">|&gt;</span> <span class="id">parse_term</span>

<span class="c">// &gt; </span>
<span class="c">// HOL.Exn+HolErr: [HZ] SYNTAX ERROR: Unexpected end of quotation instead of RHS for infix &quot;=&quot;</span>
<span class="c">// ...</span>
</code></pre>
<p>Si noti che i messaggi specifici del sistema, diversamente da quelli che derivano dall'interprete F#,<br />
in generale, hanno il prefisso `[HZ]'. Questo vale per tutti i messaggi riportati da NHOLZ, inclusi
messaggi di errore, warnings e feedback generici all'utente.</p>
<p>HOL &egrave; un linguaggio tipizzato, cos&igrave; ogni termine e sottotermine ha un tipo, e i termini
devono essere costruiti in modo da avere un tipo corretto. Questo impedisce la costruzione di enunciati
privi di significato come ''3 &egrave; uguale a vero''.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="s">&quot;3 = true&quot;</span> <span class="o">|&gt;</span> <span class="id">parse_term</span>
<span class="c">// &gt; </span>
<span class="c">// HOL.Exn+HolErr: [HZ] TYPE ERROR: Function subterm domain type incompatible with argument subterm type</span>
</code></pre>
<p>I sottotermini possono essere annotati per indicare il loro tipo, facendo seguire al sottotermine
il simbolo di i due punti <code>:</code> e poi il suo tipo, il tutto chiuso tra parentesi.
Il meccanismo di inferenza del tipo &egrave; usato per risolvere i tipi nei termini. Ad ogni termine inserito
senza annotazioni di tipo sufficienti sono assegnate delle variabili di tipo numerate per tutti i tipi non
determinabili. Di default i termini sono ristampati indietro con solamente le annotazioni di tipo sufficienti
per evitare qualsiasi ambiguit&agrave; circa i tipi di ogni sottotermine.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="s">&quot;!(w:nat) (x:nat) y z. w = x /\ y = z&quot;</span> <span class="o">|&gt;</span> <span class="id">parse_term</span>
</code></pre>
<table class="pre"><tr><td><pre><code>input.fsx (1,43)-(1,53) typecheck error The value or constructor 'parse_term' is not defined.</code></pre></td></tr></table>
<p>I tipi HOL possono essere scritti fuori dal contesto di un termine usando la funzone <code>parse_type</code>.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="s">&quot;nat#nat-&gt;bool&quot;</span> <span class="o">|&gt;</span> <span class="id">parse_type</span>
</code></pre>
<table class="pre"><tr><td><pre><code>input.fsx (1,20)-(1,30) typecheck error The value or constructor 'parse_type' is not defined.</code></pre></td></tr></table>
<h2><a name="1-3-2-Teoremi-Dimostrazioni-ed-Asserzioni" class="anchor" href="#1-3-2-Teoremi-Dimostrazioni-ed-Asserzioni">1.3.2 Teoremi, Dimostrazioni ed Asserzioni</a></h2>
<p>I teoremi HOL consistono di un insieme di termini di assunzione con valore booleano e di un termine conclusione con
valore booleano, e sono riservati ad enunciati di cui si &egrave; stabilito che valgono (per dimostrazione o asserzione
- si veda sotto). Il significato di tali enunciati &egrave; che la conclusione vale assumendo che valgano tutte le assunzioni.
I teoremi sono mostrati usando un runstile (<code>|-</code>) per separare tutte le assunzioni dalla conclusione. Il sistema di base
contiene gi&agrave; oltre 100 teoremi pre-dimostrati, ognuno dei quali non ha assunzione. Questi sono elencati
nell'Appendice B2.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="id">excluded_middle_thm</span>
</code></pre>
<table class="pre"><tr><td><pre><code>input.fsx (1,1)-(1,20) typecheck error The value or constructor 'excluded_middle_thm' is not defined.</code></pre></td></tr></table>
<p>Le regole di inferenza della logica HOL sono implementate in NHOLZ come funzioni F# che prendono
teoremi e/o termini e restituiscono teoremi. Un passo di dimostrazione &egrave; eseguito semplicemente
valutando l'applicazione di una tale funzione. Dettagli sulle regole d'inferenza sono forniti
nell'<a href="A5_Inference_Rules.html">Appendice A5</a></p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="s">&quot;x + y &lt; 5&quot;</span> <span class="o">|&gt;</span> <span class="id">parse_term</span> <span class="o">|&gt;</span> <span class="id">assume_rule</span>
<span class="c">// val it : thm = x + y &lt; 5 |- x + y &lt; 5</span>

<span class="id">spec_rule</span> <span class="pn">(</span><span class="s">&quot;a = 0&quot;</span> <span class="o">|&gt;</span> <span class="id">parse_term</span><span class="pn">)</span> <span class="id">excluded_middle_thm</span>
<span class="c">// val it : thm = |- a = 0 \/ ~ (a = 0)</span>
</code></pre>
<p>Le dimostrazioni sono semplicemente espressioni F# composte con applicazioni di regole di inferenza ad ogni livello.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="id">deduct_antisym_rule</span>
    <span class="pn">(</span><span class="id">contr_rule</span> <span class="pn">(</span><span class="s">&quot;~ true&quot;</span> <span class="o">|&gt;</span> <span class="id">parse_term</span><span class="pn">)</span> <span class="pn">(</span><span class="id">assume_rule</span> <span class="pn">(</span><span class="s">&quot;false&quot;</span> <span class="o">|&gt;</span> <span class="id">parse_term</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span>
    <span class="pn">(</span><span class="id">eq_mp_rule</span> <span class="pn">(</span><span class="id">eqf_intro_rule</span> <span class="pn">(</span><span class="id">assume_rule</span> <span class="pn">(</span><span class="s">&quot;~ true&quot;</span> <span class="o">|&gt;</span> <span class="id">parse_term</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span> <span class="id">truth_thm</span><span class="pn">)</span>
<span class="c">// val it : thm = |- ~ true &lt;=&gt; false</span>
</code></pre>
<p>il sistema di base supporta le seguenti teorie matematiche di base: logica predicativa, lambda calcolo,
coppie ordinate e aritmetica dei numeri naturali. Dettagli circa ogni teoria sono forniti
nell'<a href="B1_Teorie.html">Appendice B1</a>.</p>
<p>Le teorie del sistema possono essere estese usando i comandi di teoria per dichiarare nuove
costanti e costanti di tipo e per enunciare proposizioni a loro riguardo. Per esempio, il
comando di definizione di costante introduce una nuova costante e restituisce un nuovo
teorema, che afferma che il valore della costante &egrave; uguale a un'espressione data.
Prende un termine di uguaglianza con la nuova costante come lato sinistro del'eguaglianza e
il valore della costante come lato destro. Dettagli su ciascun comendo di teoria sono forniti
nell'Appendice A4.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="s">&quot;max_height = 7&quot;</span> <span class="o">|&gt;</span> <span class="id">parse_term</span> <span class="o">|&gt;</span> <span class="id">new_const_definition</span>
<span class="c">// [HZ] Declaring constant &quot;max_height&quot;.</span>
<span class="c">// [HZ] Adding definition for constant &quot;max_height&quot;.</span>
<span class="c">// val it : thm = |- max_height = 7</span>
</code></pre>

                </div>
            </div>
        </div>
        
    </div>

    <!-- BEGIN SEARCH BOX: this adds support for the search box -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/JavaScript-autoComplete/1.0.4/auto-complete.css" />
    <script type="text/javascript">var fsdocs_search_baseurl = '/nholz/'</script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.8/lunr.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/JavaScript-autoComplete/1.0.4/auto-complete.min.js"></script>
    <script type="text/javascript" src="/nholz/content/fsdocs-search.js"></script>
    <!-- END SEARCH BOX: this adds support for the search box -->
</body>

</html>